# Временные ряды

## План работ

1. **Контекст и Анализ**:
   - Цель проекта — разработка Telegram-бота для предоставления пользователям прогноза цен акций и торговых рекомендаций на основе анализа временных рядов. Бизнес-проблема — автоматизация анализа рынка акций для неискушённых пользователей, предлагающая им структурированный инвестиционный инсайт. Ключевые сущности: пользовательский запрос (тикер, сумма), исторические данные котировок, прогнозные модели (ML, статистическая, нейросетевая), инвестиционная рекомендация (дни покупки/продажи, прибыль), лог сессии. Ограничения: необходимость реализации минимум трёх разных моделей, обоснованный выбор лучшей, обработка некорректного ввода. Подразумеваемые нефункциональные требования: производительность (приемлемое время ответа бота на запрос, включая обучение моделей), надёжность (обработка ошибок загрузки данных), масштабируемость (возможность увеличения пула моделей или источников данных).

2. **Архитектурные решения и Технологический стек**:
   - Архитектура: модульный монолит с чётким разделением ответственности (ядро бота, сервис данных, движок ML, сервис логирования). Взаимодействие синхронное в рамках одного процесса. Технологический стек: Python, фреймворк для бота — `python-telegram-bot`, для загрузки данных — `yfinance`, для анализа и ML — `pandas`, `scikit-learn`, `statsmodels`, `prophet`, `torch` (для LSTM/GRU), для визуализации — `matplotlib`. База данных не требуется, данные загружаются на лету, логи пишутся в файл (CSV). Инфраструктура: виртуальное окружение (`venv`), файловая система для кэша и логов. Использование существующего фреймворка на базе `BaseController`, `TelegramClient`, `Router` для обработки команд и рендеринга интерфейса. Данный модули полностью разработаны с нуля и реализуют удобные интерфейсы для разработки бота

3. **План разработки с детализацией по компонентам**:
   **Модуль: Конфигурация и утилиты**
   - **Ключевые файлы/классы:** `config.py`, `utils/helpers.py`
   - **Работы:** 1. Создание файла конфигурации для хранения констант (токен бота, параметры загрузки данных). 2. Написание утилит для обработки ошибок, валидации тикеров, форматирования сообщений.

   **Модуль: Взаимодействие с данными (Data Fetcher)**
   - **Ключевые файлы/классы:** `services/data_service.py` (класс `DataService`), `models/data_point.py`
   - **Работы:** 1. Реализация загрузки исторических данных через `yfinance` по тикеру за 2 года. 2. Предобработка данных (очистка от пропусков, создание признаков: лаги, скользящие средние). 3. Кэширование загруженных данных во временные CSV-файлы для ускорения повторных запросов.

   **Модуль: Движок прогнозирования (ML Engine)**
   - **Ключевые файлы/классы:** `models/ml_model.py` (абстрактный базовый класс), `models/rf_model.py`, `models/arima_model.py`, `models/lstm_model.py`, `services/model_selector.py` (класс `ModelSelector`)
   - **Работы:** 1. Реализация трёх конкретных моделей-наследников с единым интерфейсом (`fit`, `predict`, `evaluate`). 2. В `ModelSelector` — логика разделения на train/test, обучение всех моделей, вычисление метрик (RMSE, MAPE), выбор лучшей. 3. Функция построения прогноза на 30 дней с помощью лучшей модели.

   **Модуль: Генератор рекомендаций и прибыли (Analytics Service)**
   - **Ключевые файлы/классы:** `services/analytics_service.py` (класс `AnalyticsService`)
   - **Работы:** 1. Алгоритм анализа прогнозного ряда для поиска локальных минимумов (покупка) и максимумов (продажа). 2. Логика расчёта условной прибыли на основе введённой суммы и сгенерированных рекомендаций. 3. Формирование текстовой сводки для пользователя.

   **Модуль: Визуализация (Plot Service)**
   - **Ключевые файлы/классы:** `services/plot_service.py` (класс `PlotService`)
   - **Работы:** 1. Создание функции `create_forecast_plot`, строящей график с историческими и прогнозными данными. 2. Сохранение графика в временный PNG-файл для отправки в Telegram.

   **Модуль: Логирование (Logger)**
   - **Ключевые файлы/классы:** `services/log_service.py` (класс `LogService`)
   - **Работы:** 1. Реализация записи структурированной строки лога (с параметрами сессии) в CSV-файл `logs.csv` при каждом запросе. 2. Обеспечение корректного формата данных и потока записи.

   **Модуль: Ядро Telegram-бота (Bot Core)**
   - **Ключевые файлы/классы:** `controllers/stock_controller.py` (класс `StockController`), `main.py` (маршрутизация)
   - **Работы:** 1. Создание контроллера-наследника `BaseController` с методами `menu`, `start_forecast`, `handle_ticker_input`, `handle_amount_input`. 2. Реализация логики пошагового сценария (FSM) через поля формы (`FormField`) для ввода тикера и суммы. 3. Оркестрация вызовов сервисов (Data, ML Engine, Analytics, Plot, Log) в методе обработки завершённой формы. 4. Регистрация маршрутов в `main.py`: `router.route("/", stock_controller.menu)`, `router.route("/forecast", stock_controller.start_forecast)`, `router.route("/forecast/ticker", stock_controller.handle_ticker_input)`, и т.д.

4. **Интеграция и Тестирование**:
   - Интеграция: Модули интегрируются через вызовы методов в основном потоке обработки сообщения бота. Контроллер StockController будет инжектить или создавать экземпляры сервисов (DataService, ModelSelector и др.) и вызывать их методы в нужной последовательности для обработки запроса. Последовательность: `Bot Core` -> `Data Fetcher` -> `ML Engine` -> `Analytics Service` + `Plot Service` -> `Logger`. `ML Engine` использует модели как плагины через единый интерфейс. Тестирование: Юнит-тесты (pytest) для ключевых функций сервисов (например, `DataService.validate_ticker`, `ModelSelector.calculate_metrics`). Интеграционные тесты для проверки полного пайплайна на моковых данных. Конфигурационные файлы: `requirements.txt`, `.env.example` (для токена). Для реализации пошагового ввода (тикер, затем сумма) будет использован механизм форм (FormField) существующего фреймворка.

5. **Развертывание и Документация**:
   - Развертывание: Установка зависимостей из `requirements.txt`, настройка переменной окружения `BOT_TOKEN`, запуск скрипта `main.py`. При использовании Docker — сборка образа и запуск контейнера. Миграции БД не требуются. Документация: Подробный `README.md` с инструкцией по установке, настройке и запуску. Docstring ко всем основным классам и функциям. Генерация документации API не требуется, но можно добавить примеры использования в README. Описание логики работы ключевых алгоритмов (выбор модели, генерация рекомендаций) в комментариях кода.